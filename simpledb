#!/bin/bash

# todo
# add type as extension of database file <dname.type>
# change current to a soft link
# make -l list types
# -g, get entry from the database if supported (dict)
# -r <string>, remove entry if type supports remove (below):
#	dict, remove by key
# -cp <loc>, copy current database file to location loc
# make database creation check for database name in archive
# -ar, archive current database and remove as current
# -uar <dname>, un-archive database dname
# -la, list archive database names and types

DPATH="/var/simpledb"
CPATH="config"
CURRENT="current.conf"

usage() {
	echo "$0:"
	echo "    -h - display help screen"
	echo "    -q - suppress output"
	echo "    -c <type> <dname> - create a new database, dname, with one of the following types, type:"
	echo "                    dict - key value pair database"
	echo "                    log - raw text as written"
	echo "    -s <dname> - set the database dname to the current database"
	echo "    -d - delete current database"
	echo "    -p - print raw text of current database"
	echo "    -a - add entry to current database from stdin"
	echo "    -as - add entry to current database from passed in string"
	exit 0
}

create_db() {
	type=$1
	dname=$2
	echo "creating database $dname using type $type"
	mkdir -p $DPATH
	touch $DPATH/$dname
	echo "name: $dname" >> $DPATH/$dname
	echo "type: $type" >> $DPATH/$dname
	echo "" >> $DPATH/$dname
	echo "database created"
}

delete_db() {
	dname=$1
	echo "deleting database $dname"
	curdb=$(head -1 $DPATH/$dname | cut -d ' ' -f2)
	if [ "$curdb" == "$dname" ]; then
		_delete_current
	fi
	rm -f $DPATH/$dname
	echo "database deleted"
}

_delete_current() {
	if [ -f $DPATH/$CPATH/$CURRENT ]; then
		rm -f $DPATH/$CPATH/$CURRENT
	fi
}

_get_current_name() {
	local dname=""
	if [ -f $DPATH/$CPATH/$CURRENT ]; then
		local dname=$(head -3 $DPATH/$CPATH/$CURRENT | grep "name:" | cut -d ' ' -f2)
	fi
	echo "$dname"
}

_get_current_type() {
	local type=""
	if [ -f $DPATH/$CPATH/$CURRENT ]; then
		local type=$(head -3 $DPATH/$CPATH/$CURRENT | grep "type:" | cut -d ' ' -f2)
	fi
	echo "$type"
}

set_db() {
	dname=$1
	if [ ! -d $DPATH/$CPATH ]; then
		mkdir -p $DPATH/$CPATH
	fi
	_delete_current
	head -2 $DPATH/$dname > $DPATH/$CPATH/$CURRENT
}

suppress_output() {
	exec 1>/dev/null
	exec 2>&1
}

list_dbs() {
	for file in $DPATH/*
	do
		if [ ! -f $file ]; then
			continue
		fi
		name=$(basename $file)
		echo "$name"
	done
}

print_db() {
	dname=$1
	let x=0
	while :
	do
		if ! read line
		then
			break
		fi
		if [ $x -gt 2 ]; then
			echo "$line"
		fi
		let "x = $x + 1"
	done < $DPATH/$dname
}

_add_entry_to_log() {
	dname=$1
	line=$2
	echo "$DPATH/$dname"
	echo "$line" >> $DPATH/$dname
}

_add_entry_to_dict() {
	dname=$1
	line=$2
}

_add_entry_from_stdin() {
	dname=$1
	while read line
	do
		type=$(_get_current_type)
		case $type in
			"log")
				_add_entry_to_log $dname $line
				;;
			"dict")
				_add_entry_to_dict $dname $line
				;;
			*)
				;;
		esac

	done < /dev/stdin
}

add_entry() {
	dname=$1
	str=$2
	if [ "$str" == "_STDIN" ]; then
		_add_entry_from_stdin $dname
	else
		_add_entry_from_string $dname $str
	fi
}

while (($#)) 
do
	case $1 in
		"-h")
			usage
			;;
		"-c")
                        shift
			type=$1
			shift
			dname=$1
			if [ -z $type ]; then
				echo "type not provided for -c arg"
				exit 1
			fi
			if [ -z $dname ]; then
				echo "name not provided for -c arg"
				exit 2
			fi
			if [ -f $DPATH/$dname ]; then
				echo "database already exists"
				exit 3
			fi
			if [ "$type" != "dict" ] && \
			   [ "$type" != "log" ]; then
				echo "given type does not match a known type"
				exit 4
			fi
			create_db $type $dname
			;;
		"-d")
			dname=$(_get_current_name)
			if [ ! -f $DPATH/$dname ]; then
				echo "database does not exist"
				exit 5
			fi
			delete_db $dname
			;;
		"-s")
			shift
			dname=$1
			if [ ! -f $DPATH/$dname ]; then
				echo "database does not exist"
				exit 6
			fi
			set_db $dname
			;;
		"-q")
			suppress_output
			;;
		"-l")
			list_dbs
			;;
		"-p")
			dname=$(_get_current_name)
			if [ ! -f $DPATH/$dname ]; then
				echo "database does not exist"
				exit 7
			fi
			print_db $dname
			;;
		"-a")
			dname=$(_get_current_name)
			if [ ! -f $DPATH/$dname ]; then
				echo "database does not exist"
				exit 8
			fi
			add_entry $dname "_STDIN"
			;;
		"-as")
			dname=$(_get_current_name)
			shift
			entry=$1
			if [ -z $entry ]; then
				echo "could not add empty entry"
				exit 9
			fi
			if [ ! -f $DPATH/$dname ]; then
				echo "database does not exist"
				exit 10
			fi
			add_entry $dname $entry
			;;
		*)
			echo "unknown arg: $1"
			;;
	esac
	shift
done

